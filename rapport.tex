\documentclass{article}

% Language setting
\usepackage[french]{babel}

% Set page size and margins
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{POOIG : ProtectiveTowers}
\author{Mehdi Chater \& Mathéo Piget}
\date{16 janvier 2024}

\begin{document}

\maketitle

a faire sommaire 

\section{Introduction}
Le jeu de Tower Defense que nous avons dévélopper dans le cadre de ce projet est une expérience captivante mêlant stratégie, action, et créativité. Plongé dans un univers unique, le joueur est chargé de défendre son territoire contre des vagues incessantes d'ennemis. L'objectif est de prévenir l'invasion en plaçant judicieusement des tours de défense tout en exploitant des tactiques astucieuses. Le jeu ce sépare en plusieurs fonctionalités : \\
\\
- Un systèmes de construction de tours, toutes avec des caractéristique spécial et unique \\
- Des enemis variés, des vagues d'enemis au différentes caractéristiques attaque le joueur\\
- Une interface simplet et intuitive pour ne pas perdre le joueur

\section{Besoins et Objectifs du projet}

\subsection{Contexte}

Dans le cadre d'un projet impliquant plusieurs centaines d'étudiants, la tâche ardue de rendre un projet à la fois unique et complet se présente comme un défi majeur. Ce défi stimulant incite à la créativité, à la collaboration et à la recherche de solutions innovantes.

Au-delà de la complexité du projet lui-même,Le Tower Defense, en tant que genre ludique, se démarque par sa popularité durable et sa présence constante sur nos plateformes de jeu. Depuis de nombreuses années.

Le Tower Defense offre une toile de fond idéale pour explorer et mettre en pratique les concepts théoriques acquis au cours de notre formation. En plongeant dans cet univers ludique, nous sommes confrontés à des défis concrets de conception, de programmation et de gestion de projet, faisant ainsi de cette expérience une opportunité d'apprentissage inestimable.

Dans ce contexte, le projet de Tower Defense que nous abordons représente bien plus qu'un simple exercice technique. Il incarne la convergence entre nos connaissances académiques et notre passion pour les jeux vidéo. Explorons plus en détail les motivations, les choix de conception, et les défis que nous avons relevés pour donner vie à ce projet de Tower Defense.


\subsection{Enjeux}

En concurence par des centaines d'étudiants les enjeux de ce projet sont multiple, aussi logique que ca puisse paraitre rendre un projet concret et complet parait essentiel, le projet requiert une combinaison de compétences techniques, allant de la programmation à la conception graphique. 

La capacité à jongler entre ces différentes compétences est cruciale pour le succès du Tower Defense. 

Le délai est aussi un enjeux plus que majeur, les échéances serrées imposent une pression constante. La gestion efficace du temps et la capacité à livrer des résultats de qualité dans des délais constituent un défi majeur. 

Trouver une identié propre est essentiel, aussi bien dans le code pure que dans le design.

Intégrer des éléments de programmation sans bugs, concevoir une expérience de jeu captivante et rester cohérent avec la vision initiale du projet sont autant de défis à relever. Une aciduité est essentiel afin de ne pas se perdre dans le projet, resté conhérent mais aussi maintenir une évolution constante dans le projet.

\subsection{Obectifs}

Etant un projet universitaire avec des moyens et du temps limité, les objectifs on été claire et simple dès le début, face aux défis inattendus et aux opportunités émergentes au cours du développement, nos objectifs ont évolué de manière à répondre de manière optimale aux exigences changeantes. Cette flexibilité nous a permis de s'ajuster rapidement et de prendre des décisions claires pour garantir la réussite du projet malgré les contraintes temporelles et les challenges rencontrés.

Rendre un projet sans bug et complet au minima demandé(version terminal) était essentiel a nos yeux, et était une de nos priorité.

Le partage des taches et une organisation précises sont nécéssaire et ont été nos principaux objectifs, une séparation des taches est un éléments essentiel afin de bien progresser dans le projet.

\section{Gestion de projet}

\subsection{Méthode}

Dans un délai relativement court, l'adoption d'une méthode comme SCRUM s'est avérée peu réalisable. Nous avons donc opté pour une approche simple et efficace axée sur la régularité. Chaque membre de l'équipe se consacrait quotidiennement à une tâche, sans nécessairement viser des objectifs massifs, mais avec l'engagement minimal d'une tâche par jour. Un débriefing et une "réunion" étaient organisés chaque jour (ou presque), que ce soit à travers des appels ou des messages, maintenant un contact permanent qui s'est avéré essentiel pour progresser tout en respectant les enjeux et les objectifs du projet.La composition d'une équipe de deux personnes a facilité la communication, permettant un contact direct et rapide. 

La détermination des priorités des tâches s'est révélée être un défi majeur, surtout au début du projet, où définir des priorités à partir de zéro constituait une tâche complexe. Cependant, nous avons su nous adapter et surmonter cette difficulté. Au cours des échanges quotidiens, les difficultés rencontrées ainsi que les actions entreprises étaient abordées en début de discussion. Les priorités des tâches étaient également examinées, posant des questions cruciales telles que "Que faut-il accomplir en premier ?". En fin de compte, une "mini" méthode Scrum a émergé de manière informelle, avec des revues régulières pour ajuster nos priorités et une collaboration simultanée sur différentes tâches, renforçant ainsi notre approche méthodique du développement du projet.. Le fait de séparer les taches et de travailler simultanément dessus néssité donc une platforme de gestion de version, on a donc opté pour git.


\subsection{Répartition des taches}

Étant dans la même formation, du même âge et du même "niveau", la répartition des tâches selon la spécificité de chacun n'avait pas de sens. Cependant, une distribution des rôles en fonction de nos préférences s'est avérée plus naturelle et a émergé de manière spontanée.

Mehdi, ayant une certaine familiarité avec Photoshop, s'est principalement occupé de la partie graphique et de la recherche des ressources nécessaires au bon fonctionnement du jeu. Il a notamment trouvé les graphiques des ennemis, créé les graphiques des tours et toutes les ressources graphiques associées au jeu. En plus de cela, Mehdi a également programmé les scripts de compilation et d'exécution, et a contribué à l'équilibrage du jeu, incluant la gestion de la vie des ennemis, des tours et du joueur.

Quant à Mathéo, son travail s'est principalement concentré sur le code pur. Il a créé les classes de base dès le début du projet (voir architecture du projet) et a implémenté la logique de la carte ainsi que le fonctionnement du jeu, incluant les mécanismes d'attaque des ennemis et des tours dans la version terminal, et graphique(voir difficulté rencontré). De plus, Mathéo a été responsable de la création du menu du jeu, initialement très élémentaire, mais qui a été amélioré grâce au ressources fournis par Mehdi, pour inclure les textures souhaitées, l'affichage et la mise en forme des éléments graphiques tels que les boutons et la carte.


\subsection{Architecture du Projet}
Dans un premier temps, voici un schéma de notre arborescence de fichier : 

Le projet suit une architecture de modèle Vue-Controller (MVC) pour une organisation claire et modulaire. L'arborescence des fichiers se compose de plusieurs modules dans le dossier src/main/java et des ressources dans le dossier src/main/resources. Voici une vue d'ensemble des modules:

\subsection*{Java}

\begin{itemize}
    \item \textbf{configMap:}
    \begin{itemize}
        \item La classe \texttt{GameMap} modélise la carte du jeu, gérant le placement des éléments, les attaques, et les mises à jour.
    \end{itemize}
    
    \item \textbf{launchsound:}
    \begin{itemize}
        \item Ce module intègre des interfaces pour gérer la musique du jeu, offrant une expérience sonore immersive.
    \end{itemize}

    \item \textbf{model:}
    \begin{itemize}
        \item Ce module regroupe tous les éléments présents sur la carte, tels que les ennemis et les tours. Il contient des sous-dossiers distincts pour les ennemis et les tours, organisant ainsi le code de manière logique.
    \end{itemize}

    \item \textbf{start:}
    \begin{itemize}
        \item Ce module contient le code lancé par le script d'exécution, initiant le démarrage du jeu.
    \end{itemize}

    \item \textbf{UI:}
    \begin{itemize}
        \item Ce module gère l'interface utilisateur (UI) en fonction du mode choisi (graphique ou terminal). Il contient une classe \texttt{TerminalUI} qui supervise le jeu en mode terminal.
    \end{itemize}
\end{itemize}

\subsection*{Ressources}

\begin{itemize}
    \item Les ressources nécessaires au jeu, telles que les images, les textures, etc., sont organisées en catégories dans le dossier \texttt{Ressources}. Cela facilite l'accès aux ressources depuis le code.
\end{itemize}

\subsection*{Autres Composants}

\begin{itemize}
    \item \textbf{README:}
    \begin{itemize}
        \item Fournit des instructions détaillées sur la manière de lancer et démarrer le jeu, offrant aux utilisateurs une référence claire.
    \end{itemize}

    \item \textbf{Script:}
    \begin{itemize}
        \item Le dossier \texttt{script} contient les scripts d'exécution et de compilation, simplifiant ainsi le processus pour les utilisateurs.
    \end{itemize}

    \item \textbf{Rapport:}
    \begin{itemize}
        \item Ce fichier contient le rapport actuel, documentant l'architecture du projet et pouvant être utilisé comme référence pour comprendre le développement du jeu. \\
    \end{itemize}
\end{itemize}

Cette organisation structurée facilite la maintenance, l'extension, et la collaboration entre les membres de l'équipe. Elle favorise également la lisibilité du code et la compréhension du projet dans son ensemble. Vous pourriez éventuellement envisager d'ajouter des sections spécifiques sur les technologies utilisées, les dépendances, et d'autres détails pertinents pour une vue complète du projet.



\section{Développement et Fonctionnalités}

\subsection{Organisaation du Code}

\subsubsection*{Classe \texttt{GameMap}}
La classe \texttt{GameMap} représente la carte du jeu et est essentielle pour la logique du jeu. Elle est structurée de manière à gérer le placement des éléments, les attaques, les déplacements et les mises à jour de la carte. Voici un aperçu des principales fonctionnalités et méthodes de la classe :

\begin{itemize}
    \item \textbf{Attributs :} La carte du jeu est modélisée par un tableau bidimensionnel de cellules (\texttt{tiles}), chaque cellule contenant un élément (\texttt{Element}) tel qu'une tour ou un ennemi.

    \item \textbf{Constructeur :} Le constructeur prend en compte le nombre de lignes et de colonnes pour initialiser la carte avec des cellules vides.

    \item \textbf{Méthodes :}
    \begin{itemize}
        \item \texttt{attackTowers()} : Effectue les attaques de toutes les tours présentes sur la carte.
        \item \texttt{attackEnemies(Player p)} : Effectue les attaques de tous les ennemis présents sur la carte en prenant en compte le joueur.
        \item \texttt{moveAllEnemies()} : Déplace tous les ennemis en fonction de leur vitesse.
        \item \texttt{spawnNewEnemies()} : Fait apparaître de nouveaux ennemis sur la carte après une frame.
        \item \texttt{update(Player p)} : Met à jour la carte après chaque tour, gérant les attaques, les déplacements, la suppression des éléments morts et l'apparition de nouveaux ennemis.
        \item \texttt{affiche()} : Affiche la carte dans la console, utile pour le débogage.
        \item \texttt{reset()} : Remet la carte à son état initial en retirant tous les ennemis et les tours.
    \end{itemize}
\end{itemize}

La classe \texttt{GameMap} s'inscrit dans le module \texttt{configMap}, contribuant ainsi à la modélisation et à la gestion de la carte de jeu. Sa structure modulaire et ses méthodes bien définies facilitent la compréhension, la maintenance et l'extension du code.



\subsubsection*{Classe \texttt{TerminalUI}}
La classe \texttt{TerminalUI} gère l'interface utilisateur en mode terminal du jeu. Elle permet aux joueurs d'interagir avec le jeu en affichant des menus, en consultant les règles, en plaçant des tours, etc. Voici un aperçu des principales fonctionnalités et méthodes de la classe :

\begin{itemize}
    \item \textbf{Attributs :} La classe possède des attributs tels que la carte du jeu (\texttt{map}), le joueur (\texttt{player}), un scanner pour lire l'entrée utilisateur (\texttt{scanner}), et la difficulté du jeu (\texttt{difficulty}).

    \item \textbf{Constructeur :} Le constructeur prend la carte du jeu et le joueur en argument et initialise d'autres paramètres.

    \item \textbf{Méthodes :}
    \begin{itemize}
        \item \texttt{affiche\_règles()} : Affiche les règles du jeu, les types de tours et les types d'ennemis.
        \item \texttt{affiche\_menu()} : Affiche le menu principal du jeu avec différentes options.
        \item \texttt{gererOptions()} : Gère les options du jeu, actuellement la seule option est de choisir la difficulté.
        \item \texttt{choisirDifficulte()} : Permet au joueur de choisir la difficulté du jeu.
        \item \texttt{startTerminalGame(GameMap map, Player player)} : Initialise le jeu et affiche le menu principal.
        \item \texttt{start()} : Méthode principale pour démarrer le jeu, gère les tours, les mises à jour de la carte, et détecte la fin du jeu.
        \item \texttt{displayInGameMenu()} : Affiche le menu d'action pendant le jeu, permet au joueur de placer une tour, de terminer son tour, ou de retourner au menu principal.
        \item \texttt{placeTower()} : Permet au joueur de placer une tour sur la carte en fonction de son choix et de ses fonds.
    \end{itemize}
\end{itemize}

La classe \texttt{TerminalUI} sert d'interface utilisateur et facilite l'interaction avec le jeu. Sa structure modulaire et ses méthodes spécifiques rendent le code clair et compréhensible, améliorant ainsi la maintenabilité du jeu.



\subsubsection*{Classe \texttt{GUI}}

La classe \texttt{GUI} gère l'interface utilisateur du jeu. Elle joue un rôle essentiel dans la présentation graphique du jeu, permettant aux joueurs d'interagir avec différentes parties du jeu. Voici un aperçu des principales fonctionnalités et méthodes de la classe :

\item \textbf{Constructeur :} 
\begin{itemize}
    \item \texttt{startGUIGame(GameMap map, Player player)} : Initialise la fenêtre du jeu, charge les éléments graphiques, lance la musique du menu principal et configure les différents panneaux pour les différentes sections du jeu.
\end{itemize}

\item \textbf{Méthodes :}
\begin{itemize}
    \item \texttt{createMenuPanel()} : Crée un panneau pour le menu principal, contenant des boutons pour les options du jeu.
    \item \texttt{createMainPanel()} : Crée un panneau principal avec une image de fond pour le menu.
    \item \texttt{createCreditsPanel()} : Crée un panneau pour afficher les crédits du jeu.
    \item \texttt{createRulesPanel()} : Crée un panneau pour afficher les règles du jeu.
    \item \texttt{displayRulesPanel()} : Affiche le panneau des règles du jeu.
    \item \texttt{createOptionsPanel()} : Crée un panneau pour les options du jeu.
    \item \texttt{addStyledButton(JPanel panel, String imagePath, ActionListener listener)} : Ajoute un bouton stylisé à un panneau avec une image et un auditeur d'événements associé.
    \item \texttt{showCard(String cardName)} : Permet de basculer entre les différentes "cartes" de l'interface graphique.
    \item \texttt{playSpecificMusic(String cheminMusique)} : Joue un fichier audio spécifique (musique) pendant le jeu.
    \item \texttt{stopSpecificMusic()} : Arrête la musique en cours.
    \item \texttt{startGame()} : Lance le jeu en créant l'état du jeu et en affichant le panneau de jeu.
\end{itemize}

\subsubsection*{Classe \texttt{GameState}}

La classe \texttt{GameState} est responsable de la gestion de l'état du jeu et de la logique associée à la fenêtre de jeu. Voici un aperçu des principales fonctionnalités et méthodes de la classe :

\begin{itemize}
\item \textbf{Attributs :}
\begin{itemize}
\item \texttt{gameMap} : Instance de la classe \texttt{GameMap} représentant la carte du jeu.
\item \texttt{gamePanel} : Instance de \texttt{JPanel} représentant le panneau de jeu.
\item \texttt{gameMapPanel} : Instance de la classe \texttt{GameMapPanel} représentant la carte du jeu dans le panneau.
\item \texttt{selectedTowerType} : Type de tour sélectionné par le joueur.
\item \texttt{player} : Référence vers la classe \texttt{Player} représentant le joueur du jeu.
\item \texttt{fond} : Image de fond pour la fenêtre de jeu.
\item \texttt{enemySpawnInterval} : Intervalle entre les apparitions d'ennemis.
\item \texttt{enemySpawnCounter} : Compteur pour suivre les apparitions d'ennemis.
\item \texttt{livesLabel} : JLabel affichant le nombre de vies du joueur.
\item \texttt{moneyLabel} : JLabel affichant l'argent du joueur.
\item \texttt{scoreLabel} : JLabel affichant le score du joueur.
\item \texttt{gameOverPanel} : JPanel affichant l'écran de Game Over.
\end{itemize}

scss
Copy code
\item \textbf{Constructeur :}
\begin{itemize}
    \item \texttt{GameState(GameMap map, Player player)} : Initialise la carte du jeu, le joueur et le panneau de jeu avec les éléments nécessaires, tels que les boutons pour placer des tours.
\end{itemize}

\item \textbf{Méthodes :}
\begin{itemize}
    \item \texttt{createTopPanel()} : Crée un panneau supérieur avec des boutons pour placer des tours, des labels pour afficher les informations du joueur (vie, argent, score).
    \item \texttt{createGamePanel(JPanel topPanel)} : Crée le panneau de jeu avec la carte du jeu et le panneau supérieur.
    \item \texttt{createTowerButtonWithImage(String towerType, String imagePath, int width, int height)} : Crée un bouton pour un type de tour spécifique avec une image redimensionnée.
    \item \texttt{startGameLoop()} : Démarre la boucle de jeu avec un Timer, mettant à jour la carte du jeu et vérifiant les conditions de fin de partie.
    \item \texttt{showGameOver()} : Affiche l'écran de Game Over avec un bouton pour rejouer.
    \item \texttt{updatePlayerInfoLabels()} : Met à jour les valeurs des étiquettes d'informations du joueur (vie, argent, score).
    \item \texttt{updateGame()} : Met à jour le jeu en déplaçant les ennemis et en ajoutant de nouveaux ennemis.
    \item \texttt{getGamePanel()} : Renvoie le panneau de jeu.
    \item \texttt{getSelectedTowerType()} : Renvoie le type de tour sélectionné par le joueur.
\end{itemize}
Save to grepper
\end{itemize}

La classe \texttt{GameState} est cruciale pour la gestion de la logique de jeu et offre une intégration fluide entre la carte du jeu, le joueur et l'interface graphique. Les méthodes clairement définies facilitent la compréhension et la maintenance du code.

\subsubsection*{Classe \texttt{GameMapPanel}}

La classe \texttt{GameMapPanel} représente le panneau de la carte du jeu et gère les interactions avec celle-ci. Voici un aperçu des principales fonctionnalités et méthodes de la classe :

\begin{itemize}
\item \textbf{Attributs :}
\begin{itemize}
\item \texttt{gameMap} : Instance de la classe \texttt{GameMap} représentant la carte du jeu.
\item \texttt{highlightedCellX} : Coordonnée x de la cellule mise en surbrillance par la souris.
\item \texttt{highlightedCellY} : Coordonnée y de la cellule mise en surbrillance par la souris.
\item \texttt{enemiesImages} : Map associant des noms d'ennemis à leurs images correspondantes.
\item \texttt{towerImages} : Map associant des noms de tours à leurs images correspondantes.
\item \texttt{grass} : Image représentant l'herbe de la carte.
\item \texttt{cellWidth} : Largeur d'une cellule sur la carte.
\item \texttt{player} : Référence vers la classe \texttt{Player} représentant le joueur du jeu.
\item \texttt{cellHeight} : Hauteur d'une cellule sur la carte.
\item \texttt{towerToPlace} : Type de tour à placer.
\item \texttt{isPlacingTower} : Indicateur indiquant si le joueur est en train de placer une tour.
\end{itemize}

\item \textbf{Constructeur :}
\begin{itemize}
    \item \texttt{GameMapPanel(GameMap gameMap, Player p)} : Initialise la carte du jeu, le joueur et les écouteurs de souris.
\end{itemize}

\item \textbf{Méthodes :}
\begin{itemize}
    \item \texttt{initializeImages()} : Initialise les images utilisées dans le jeu, telles que les tours, les ennemis et l'herbe.
    \item \texttt{initializeMouseListeners()} : Initialise les écouteurs de souris pour les interactions avec la carte.
    \item \texttt{setTowerToPlace(String towerType)} : Définit le type de tour à placer.
    \item \texttt{placeTowerAtReleasedPosition(int x, int y)} : Place la tour à la position relâchée.
    \item \texttt{cancelTowerPlacement()} : Annule le placement de la tour.
    \item \texttt{updateHighlightedCell(int x, int y)} : Met à jour la surbrillance de la cellule en fonction des coordonnées de la souris.
    \item \texttt{getTowerCost(String towerType)} : Obtient le coût d'une tour en fonction de son type.
    \item \texttt{placeTower(int cellX, int cellY)} : Place la tour sur la carte.
    \item \texttt{paintComponent(Graphics g)} : Redéfinition de la méthode pour dessiner les éléments de la carte, y compris les tours, les ennemis et la surbrillance des cellules.
\end{itemize}
\end{itemize}

La classe \texttt{GameMapPanel} joue un rôle essentiel dans l'affichage graphique de la carte du jeu et la gestion des interactions utilisateur. Ses méthodes claires et bien définies facilitent la compréhension et la maintenance du code.\\

On a ici résumé les principales classes qui joue un role essentiel dans le jeu que se soit en version graphique ou terminal. Les classes des enemies ne vont pas etre decrite tout comme les tours parce que très futiles.

\subsection{Fonctionnalités Principales}

\subsubsection*{Mécaniques de Jeu}

\begin{itemize}
    \item \textbf{Éléments Interactifs :} La carte du jeu est peuplée d'éléments tels que des tours et des ennemis. Chaque cellule de la carte contient un élément, et la disposition de ces éléments influence le déroulement du jeu.

    \item \textbf{Progression du Joueur :} Le joueur gagnent des points en tuant des enemis.
\end{itemize}

\subsubsection*{Attaques}

\begin{itemize}
    \item \textbf{Gestion des Attaques :} Les attaques des tours sont déclenchées périodiquement, ciblant les ennemis se situant sur la meme ligne. Les ennemis ripostent également avec leurs propres attaques.
\end{itemize}

\subsubsection*{Interactions Utilisateur}

\begin{itemize}
    \item \textbf{Placement de Tours :} Les joueurs peuvent placer des tours sur des emplacements de la carte pour renforcer leur défense.
\end{itemize}

\subsection*{Gestion des Ressources}

\subsubsection*{Images et Textures}

\begin{itemize}
    \item \textbf{Chargement des Images :} Les images et textures du jeu sont stockées dans des fichiers séparés. Le jeu les charge dynamiquement lors de son exécution.

    \item \textbf{Format des Images :} Les images sont au format PNG pour assurer une qualité graphique optimale tout en minimisant la taille des fichiers.
\end{itemize}

\subsubsection*{Fichiers Sonores}

\begin{itemize}
    \item \textbf{Musique de Fond :} La musique de fond du jeu est également gérée en tant que ressource sonore, contribuant à l'ambiance globale.
\end{itemize}

\subsubsection*{Fichiers de Configuration}

\begin{itemize}
    \item \textbf{Paramètres du Jeu :} dans la version terminal, les parametres sont accesibles depuis un menu et permette de regler la difficulté, ce qui influ sur l'argent gagné durant le jeu en tuant les enemis, dans la version graphique, le choix de difficultés n'est pas disponible(voir probleme rencontré) mais un boutton pour mettre le son a zéro est visible.
\end{itemize}


\subsection*{Logique de Jeu}
Le jeu se déroule de manière tour par tour, où le joueur a la possibilité de décider quand terminer son tour dans la version en mode terminal, tandis que dans la version graphique, le jeu s'actualise à des intervalles réguliers. Les ennemis se déplacent à différentes vitesses et infligent des dommages variables. L'ordre d'exécution des actions à chaque tour est soigneusement orchestré pour maintenir l'équilibre et l'interaction dynamique entre les tours et les ennemis.

Au début de chaque tour, les tours sur la carte attaquent les ennemis à portée. Cette phase stratégique permet au joueur de planifier ses défenses et d'optimiser les attaques de ses tours pour contrer les vagues d'ennemis. Ensuite, les ennemis effectuent leurs attaques, infligeant des dégâts aux tours sur leur chemin.

La phase suivante concerne la récolte des récompenses. Le joueur gagne de l'argent en fonction des types d'ennemis éliminés et de la difficulté. Cette ressource financière est essentielle pour en construire de nouvelles.

Après la collecte des récompenses, la carte est mise à jour pour retirer les ennemis vaincus et les tours détruites. Les ennemis restants avancent d'une certaine distance, et de nouveaux ennemis apparaissent sur la carte, introduisant un défi constant.

\section{Difficultés Rencontrées}
Lors du développement, plusieurs difficultés ont émergé, chacune nécessitant une attention particulière. L'une des premières problématiques a été la découverte d'un fichier inattendu, "GUI\$1.class", au cours des premiers essais de script de compilation. La gestion des coordonnées des éléments a également posé des défis, nécessitant une configuration minutieuse pour garantir un positionnement précis sur la carte du jeu. Un problème notable a été identifié avec les boutons du menu graphique, qui rencontraient des bogues résolus grâce à un ajustement du layout. Par ailleurs, dans le menu terminal, un problème persistait où la fenêtre du jeu passait d'une frame à l'autre même en l'absence de la pose d'une tour. Ces difficultés ont demandé des efforts conséquents pour les résoudre, mais chaque défi surmonté a contribué à améliorer la qualité globale du jeu.\\

Au cours du développement, l'équipe a été confrontée à une difficulté importante liée à la gestion des déplacements fluides des ennemis. Initialement, le choix de coordonnées entières pour représenter la position des éléments sur la carte a entraîné des mouvements saccadés lors des déplacements des ennemis. Nous avons sous-estimé l'impact de cette décision sur la fluidité du jeu.

L'utilisation de coordonnées entières a rendu complexe la mise en œuvre de mouvements continus, ce qui aurait été nécessaire pour un déplacement en temps réel des ennemis. Ce défi a conduit à une réévaluation de notre approche et a motivé le choix de maintenir le jeu dans un format de tour par tour. Bien que cela puisse être perçu comme une limitation, cela a permis d'assurer des déplacements sans accroc, offrant ainsi une expérience de jeu plus stable et prévisible.

Cette difficulté a mis en lumière l'importance cruciale de la conception initiale et de l'anticipation des besoins du jeu. En réfléchissant à l'interaction entre les éléments du jeu, en particulier les mouvements des ennemis, nous aurions pu envisager dès le départ l'utilisation de coordonnées réelles pour permettre un déplacement fluide. Cependant, cette expérience a été un enseignement précieux sur l'importance de l'itération et de l'adaptabilité dans le processus de développement de jeux vidéo.

\section{Conclusion}
Au cours du développement de ce jeu de tower defense, notre équipe a relevé divers défis qui ont enrichi notre expérience et renforcé nos compétences en programmation et en conception de jeux. L'un des aspects clés du projet a été la mise en œuvre des fonctionnalités principales qui définissent l'essence même du jeu. Le choix d'une architecture modulaire s'est avéré judicieux, facilitant l'extension du jeu avec de nouvelles fonctionnalités et garantissant une maintenance plus aisée.

La gestion des ressources a introduit une dimension stratégique cruciale, obligeant les joueurs à optimiser leur économie pour construire des tours efficaces et faire face à des vagues d'ennemis. Cette composante a nécessité une équilibration minutieuse pour garantir un défi stimulant sans pour autant décourager les joueurs.

La logique du jeu, décrite dans la section correspondante, a été conçue pour créer une expérience de jeu immersive. Les tours attaquent avec précision, les ennemis réagissent de manière réaliste, et la récompense en argent pour la destruction d'ennemis renforce le sentiment de progression. Les mécanismes de tour par tour, que ce soit à l'initiative du joueur en mode terminal ou grâce à l'actualisation régulière en mode graphique, contribuent à maintenir un rythme dynamique.

Les difficultés rencontrées, telles que les bugs dans l'interface graphique et les problèmes de disposition des éléments, ont été des opportunités d'apprentissage. La persévérance de l'équipe dans la résolution de ces problèmes a renforcé notre compréhension des nuances du développement de jeux, notamment en termes de gestion d'interface utilisateur et d'intégration de fonctionnalités interactives.

En ce qui concerne la conclusion, ce projet ne se limite pas à une simple réalisation technique. Il représente l'aboutissement d'un processus créatif et collaboratif où chaque membre de l'équipe a contribué de manière significative. L'adaptabilité du code aux ajustements et aux itérations successives a été une clé majeure du succès, tout comme l'attention portée aux détails pour garantir une expérience de jeu cohérente et agréable.

En fin de compte, ce jeu de tower defense va au-delà d'une simple application informatique. Il incarne une exploration constante des défis de conception, des solutions novatrices aux problèmes techniques, et une passion partagée pour la création de divertissements interactifs. Nous sommes impatients de partager ce jeu avec le public, espérant qu'il suscitera l'enthousiasme des joueurs et ouvrira la voie à de nouvelles aventures dans le monde du développement de jeux. Que ce projet soit le premier de nombreux succès à venir pour notre équipe créative.

\section*{Bibliographie}
Si vous avez utilisé des ressources externes, référencez-les ici.







\end{document}
